<!doctype html><html lang="pl"><head><meta charset="utf-8" /><title>Solana Full Stack – 50 Pytań Technicznych (Prosto + Głęboko)</title><meta name="viewport" content="width=device-width,initial-scale=1" /><style>:root{--accent:#0a7cff;--fg:#111;--muted:#555;--bg:#fff;--code:#f5f7fa}body{margin:0;font:14.8px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;color:var(--fg);background:var(--bg);}main{max-width:1020px;margin:28px auto 120px;padding:0 22px;}h1{font-size:30px;margin:0 0 4px;}h2{font-size:20px;margin:40px 0 12px;border-bottom:1px solid #e5ecf3;padding-bottom:4px;}h3{font-size:15px;margin:22px 0 6px;color:var(--muted);}p{margin:8px 0;}a{color:var(--accent);text-decoration:none;}a:hover{text-decoration:underline;}button#print{background:var(--accent);color:#fff;border:0;padding:10px 16px;border-radius:6px;cursor:pointer;font-weight:600;}button#print:hover{filter:brightness(1.08);}code{background:var(--code);padding:2px 5px;border-radius:4px;font-size:13px;}pre{background:var(--code);padding:10px 14px;border-radius:8px;overflow:auto;font-size:13px;}ol.toc{columns:2;gap:32px;margin:12px 0 0;padding-left:20px;}ol.toc li{break-inside:avoid;margin:2px 0;}@media (max-width:820px){ol.toc{columns:1;}}.qa{margin:28px 0;padding:0 0 16px;border-bottom:1px dashed #e2e8f0;} .q{font-weight:600;font-size:15px;margin-bottom:6px;} .simple{background:#f6f9fc;padding:8px 12px;border-left:4px solid var(--accent);border-radius:4px;margin:4px 0;} .deep{margin:6px 0 0;font-size:13.8px;} .badge{display:inline-block;background:#e7f3ff;color:#035da8;font-size:11px;font-weight:600;letter-spacing:.5px;padding:2px 6px;border-radius:4px;margin-left:6px;vertical-align:middle;} .cluster{display:flex;flex-wrap:wrap;gap:6px;margin:10px 0;} .tag{background:#eef2f6;color:#334155;font-size:11px;padding:4px 7px;border-radius:4px;} .flash{background:#111;color:#fff;font-size:12px;padding:10px 14px;border-radius:10px;display:flex;flex-wrap:wrap;gap:8px;} .group-title{font-size:17px;margin:34px 0 4px;font-weight:600;} .meta{color:var(--muted);margin-bottom:18px;} .footer{margin-top:70px;font-size:12.5px;color:var(--muted);} .print-hint{font-size:12px;color:var(--muted);margin-top:6px;} @media print{button#print,.print-hide{display:none!important;} ol.toc{columns:3;} @page{size:A4;margin:14mm;} body{font-size:12.5px;} .qa{page-break-inside:avoid;} }</style></head><body><main><h1>Solana – 50 Pytań na Rozmowę (Full Stack)</h1><div class="meta">Wersja: 2025‑11‑07 • Format: Prosto + Głębiej • Zapisz jako PDF przyciskiem poniżej.</div><div class="print-hide" style="margin:8px 0 24px;display:flex;flex-direction:column;align-items:flex-start;gap:6px"><button id="print" onclick="window.print()">Drukuj / Zapisz jako PDF</button><div class="print-hint">Ctrl+P → Destination: Save as PDF → Margins: Normal → Disable headers/footers → Save.</div></div><h2>Spis treści (50)</h2><ol class="toc"><li><a href="#p1">Blockchain</a></li><li><a href="#p2">PoW vs PoS</a></li><li><a href="#p3">Solana a PoW / Bridging</a></li><li><a href="#p4">Staking SOL – podstawy</a></li><li><a href="#p5">Dlaczego staking</a></li><li><a href="#p6">Proof of History (PoH)</a></li><li><a href="#p7">Epoki</a></li><li><a href="#p8">Slot / Leader</a></li><li><a href="#p9">Validator rola</a></li><li><a href="#p10">NRR vs GRR</a></li><li><a href="#p11">MEV idea</a></li><li><a href="#p12">Konto stake</a></li><li><a href="#p13">Delegacja bezpieczeństwo</a></li><li><a href="#p14">Dodawanie stake (merge)</a></li><li><a href="#p15">Nagrody & compounding</a></li><li><a href="#p16">Wybór validatora</a></li><li><a href="#p17">Inflacja a APR</a></li><li><a href="#p18">Priority fees</a></li><li><a href="#p19">Gulf Stream</a></li><li><a href="#p20">Parallelization (TPU)</a></li><li><a href="#p21">Accounts model</a></li><li><a href="#p22">Programy BPF</a></li><li><a href="#p23">Anchor framework</a></li><li><a href="#p24">Bezpieczeństwo programów</a></li><li><a href="#p25">Audyt – testy fuzz</a></li><li><a href="#p26">Mosty (bridges)</a></li><li><a href="#p27">Cross-chain ryzyka</a></li><li><a href="#p28">Storage / rent</a></li><li><a href="#p29">RPC vs Validator</a></li><li><a href="#p30">Indexing danych</a></li><li><a href="#p31">Realtime dashboard</a></li><li><a href="#p32">Monitoring metryki</a></li><li><a href="#p33">HA validatora</a></li><li><a href="#p34">Failover mechanizmy</a></li><li><a href="#p35">Klucze & HSM</a></li><li><a href="#p36">Slashing dziś / przyszłość</a></li><li><a href="#p37">MEV detekcja</a></li><li><a href="#p38">API staking wielo-sieci</a></li><li><a href="#p39">Autoryzacja API</a></li><li><a href="#p40">Rate limiting & QoS</a></li><li><a href="#p41">Widget stakingowy</a></li><li><a href="#p42">Integracja Phantom</a></li><li><a href="#p43">Ledger integracja</a></li><li><a href="#p44">Compounding strategia</a></li><li><a href="#p45">Raportowanie rewards</a></li><li><a href="#p46">MEV podział</a></li><li><a href="#p47">Decentralizacja klientów</a></li><li><a href="#p48">Multi-region design</a></li><li><a href="#p49">SOC2 / compliance</a></li><li><a href="#p50">System design 10B+ TVL</a></li></ol><h2>Q&A (Prosto + Głębiej)</h2><div class="flash"><span>Format: Każde pytanie = uproszczenie + sekcja techniczna.</span><span>Cel: Przygotowanie do rozmowy Full Stack (Solana).</span></div>
<!-- Begin QAs -->
<div class="qa" id="p1"><div class="q">1) Co to jest blockchain?</div><div class="simple">Jak wspólny zeszyt online – wszyscy widzą wpisy i nikt nie ma gumki do ścierania.</div><div class="deep"><p><strong>Definicja:</strong> Rozproszony, append‑only rejestr transakcji i stanu utrzymywany przez sieć węzłów bez centralnego zaufania. Każdy blok zawiera hash poprzedniego, tworząc łańcuch odporności na modyfikacje.</p><p><strong>Składniki:</strong> (1) Bloki (transakcje + metadata + hash poprzednika), (2) Konsensus (PoS/PoH na Solanie – deterministyczny leader schedule), (3) Sieć P2P (propagacja bloków/tx), (4) Kryptografia (podpisy Ed25519, hashe SHA256), (5) Reguły walidacji (spójność stanu, podpisy, limity zasobów), (6) Storage ledger (snapshot + append log).</p><p><strong>Niezmienność:</strong> Modyfikacja bloku zmienia jego hash → kaskadowo łamie kolejne. Atak wymaga kontroli ekonomicznej (hashpower/stake) oraz nadrobienia czasu/slotów. W Solanie szybka produkcja slotów + PoH utrudnia cofanie historii.</p><p><strong>Finalność a UX:</strong> Poziomy commitment (processed/confirmed/finalized) wpływają na moment pokazania użytkownikowi „gotowe”. Full Stack musi zrozumieć różnice by uniknąć błędnego stanu (np. wyświetlenie salda przed finalized).</p><p><strong>Integracja aplikacyjna:</strong> Warstwa backend używa indeksera do dekodowania transakcji i budowy modeli domenowych; frontend reaguje na WebSocket subskrypcje (sloty/głosy) dla near‑real‑time aktualizacji.</p><p><strong>Bezpieczeństwo ekonomiczne:</strong> Atak wymaga przejęcia znacznego stake (PoS) – trudne finansowo. Rozproszenie walidatorów zwiększa koszt cenzury lub reorganizacji.</p><p><strong>Najczęstsze błędne założenia:</strong> „Blockchain = wolny” – Solana obala tę tezę dzięki pipeliningowi (TPU) i PoH (redukcja potrzeby globalnego timestamp). „Blockchain = transakcje tylko finansowe” – w praktyce ogólny rejestr stanów programów (kont).</p></div></div>
<div class="qa" id="p2"><div class="q">2) Różnica Proof of Work vs Proof of Stake?</div><div class="simple">PoW: ścigamy się w zagadkach. PoS: głosujemy zamrożonymi monetami.</div><div class="deep"><p><strong>PoW (Proof of Work):</strong> Węzły (górnicy) rozwiązują kosztowne puzzle kryptograficzne (hashing) by zaproponować blok. Bezpieczeństwo wynika z realnego kosztu energii i sprzętu – sfałszowanie historii wymaga ogromnych nakładów.</p><p><strong>PoS (Proof of Stake):</strong> Węzły (walidatorzy) blokują stake (tokeny) i proporcjonalnie do jego wielkości uczestniczą w produkcji/głosowaniu nad blokami. Kara ekonomiczna (slashing lub utrata nagród) zniechęca do złego zachowania.</p><p><strong>Różnice praktyczne:</strong></p><ul><li><em>Latencja/finalność:</em> PoS zwykle osiąga szybsze potwierdzenia; Solana łączy PoS z PoH (kryptograficzny zegar) dla niskiej latencji i deterministycznego leader schedule.</li><li><em>Energia:</em> PoW zużywa dużo energii; PoS ma znacznie mniejszy ślad energetyczny.</li><li><em>Atak 51%:</em> PoW wymaga większości mocy obliczeniowej; PoS – większości stake (bariera finansowa).</li></ul><p><strong>Konsekwencje dla Full Stack:</strong> W Solanie oprócz „czy transakcja przeszła” ważny jest poziom commitment (processed/confirmed/finalized). Krótsza latencja = lepszy UX, ale krytyczne operacje (wypłaty) powinny czekać na finalized.</p></div></div>
<div class="qa" id="p3"><div class="q">3) Solana a PoW / integracje z Bitcoinem?</div><div class="simple">Solana sama nie jest PoW, ale może mieć tokeny z sieci PoW (owinięte BTC).</div><div class="deep"><p><strong>Model:</strong> Solana nie łączy konsensusu z PoW. Integracja z łańcuchami PoW (np. BTC) odbywa się przez mosty i wrapped assets (np. wBTC).</p><p><strong>Typy mostów:</strong> custodial/multi‑sig (powiernicy), light‑client (weryfikacja nagłówków in‑chain), optimistic (okno wyzwań). Każdy ma inny profil ryzyka i opóźnień.</p><p><strong>Ryzyka:</strong> Exploit mostu → mint niepokrytych tokenów → depeg. Reorg po stronie PoW może opóźnić lub cofnąć „lock”. Centralizacja guardianów = single point of failure.</p><p><strong>Higiena produkcyjna:</strong> Audyty kodu mostu, monitoring TVL, jawne raporty (np. merkle root locków), health‑checks w UI (pokaż ostrzeżenia, gdy most degraduje się).</p><p><strong>Wniosek:</strong> Konsensus Solany (PoH+PoS) nie „miesza się” z PoW – mosty wyłącznie przenoszą reprezentację aktywów między łańcuchami.</p></div></div>
<div class="qa" id="p4"><div class="q">4) Jak stakować SOL krok po kroku?</div><div class="simple">Tworzysz konto stake, wybierasz validatora, blokujesz SOL, czekasz na nagrody.</div><div class="deep"><p><strong>Cel:</strong> utworzyć i zdelegować konto stake, monitorować aktywację, a w razie potrzeby podzielić/połączyć/dezaktywować/wypłacić. <strong>Komponenty:</strong> StakeProgram (Stake111...), Stake Account (Authorized: staker/withdrawer, Lockup), Vote Account (walidator), Epoki (warmup/cooldown), Rent‑exempt.</p><h4>CLI (użytkownik)</h4><ol><li>Klucz stake: <code>solana-keygen new -o stake.json</code></li><li>Utwórz i zasil konto: <code>solana create-stake-account stake.json 10 SOL</code></li><li>Deleguj: <code>solana delegate-stake stake.json VOTE_ACCOUNT</code></li><li>Status: <code>solana stake-account stake.json</code></li><li>Wyjście: <code>solana deactivate-stake stake.json</code> → po Inactive: <code>solana withdraw-stake stake.json TWÓJ_PUBKEY LAMPORTS</code></li><li>Split/Merge: <code>solana split-stake stake.json new.json 2 SOL</code>; <code>solana merge-stake A.json B.json</code> (oba Inactive, zgodne authorities).</li></ol><h4>Programistycznie (TypeScript, @solana/web3.js)</h4><ul><li>Rent: <code>getMinimumBalanceForRentExemption(StakeProgram.space)</code>; <code>stakeAccount = Keypair.generate()</code></li><li>Tworzenie: <code>SystemProgram.createAccount({space: StakeProgram.space, programId: StakeProgram.programId, lamports: rent + kwota})</code></li><li>Init: <code>StakeProgram.initialize({stakePubkey, authorized: new Authorized(staker, withdrawer), lockup: new Lockup(0,0,Pubkey('1111..'))})</code></li><li>Delegacja: <code>StakeProgram.delegate({stakePubkey, authorizedPubkey: staker, votePubkey})</code></li><li>Utrzymanie: <code>StakeProgram.split</code>, <code>StakeProgram.merge</code> (oba Inactive), <code>StakeProgram.authorize</code>, <code>StakeProgram.deactivate</code> → withdraw.</li></ul><h4>Lifecycle i nagrody</h4><ul><li>Stany: Inactive → Activating → Active → Deactivating → Inactive (epokowo).</li><li>Nagrody doliczane do salda stake co epokę (brak „claim”).</li><li>Warmup/cooldown: duże wejścia/wyjścia rozkładane w czasie.</li></ul><h4>Bezpieczeństwo i edge‑cases</h4><ul><li>Rozdziel staker/withdrawer (withdrawer najlepiej offline/HSM).</li><li>Durable Nonce dla długich podpisów (HSM/Ledger).</li><li>Waliduj <code>votePubkey</code>, monitoruj commission/uptime.</li><li>Błędy: za mało rent → konto bezużyteczne; <code>TransactionExpiredBlockheight</code> → odśwież blockhash; split przed pełną aktywacją → częściowa aktywacja w obu częściach.</li></ul><h4>Optymalizacje</h4><ul><li>v0 + ALT dla wielu kont; <code>ComputeBudgetProgram.setComputeUnitLimit/Price</code> dla priorytetu.</li><li>Batch compounding: progowy withdraw → create/init/delegate.</li><li>Okresowy merge Inactive redukuje footprint i rent.</li></ul></div></div>
<div class="qa" id="p5"><div class="q">5) Po co w ogóle staking?</div><div class="simple">Monety pracują i pomagają sieci.</div><div class="deep"><p><strong>Ekonomia:</strong> Wynagrodzenie delegatora składa się z inflacji (emisja), części opłat (fees) i ewentualnego MEV share, pomniejszone o commission walidatora.</p><p><strong>Bezpieczeństwo:</strong> Duży, zdywersyfikowany stake zwiększa koszt ataku (cenzura/reorg) oraz stabilność sieci.</p><p><strong>Decyzje delegatora:</strong> wybór walidatora (commission, uptime, vote success %, przejrzystość), dywersyfikacja, rebalans. Mierz NRR (net) zamiast samego GRR (brutto).</p><p><strong>Ryzyka:</strong> Centralizacja stake, nagłe zmiany prowizji, słaby uptime (missed votes → niższe nagrody), ryzyko operacyjne walidatora.</p><p><strong>Strategie:</strong> Compounding według progu (ekonomiczny sens vs opłaty i rent), okresowy przegląd walidatorów, alarmy gdy efektywny stake spada.</p></div></div>
<div class="qa" id="p6"><div class="q">6) Proof of History (PoH) – co daje?</div><div class="simple">Maszynka robi chronologiczne pieczątki.</div><div class="deep"><p><strong>Idea:</strong> PoH to ciągłe, weryfikowalne sekwencyjne hashowanie, które tworzy „zegar kryptograficzny” – łatwo zweryfikować, że pomiędzy dwoma punktami upłynął czas i kolejność zdarzeń jest deterministyczna.</p><p><strong>Skutki inżynierskie:</strong> Minimalizacja potrzeby globalnej synchronizacji czasu → możliwość głębokiego pipeliningu (fetch → sigverify → banking → proof). Zmniejsza overhead koordynacji między walidatorami.</p><p><strong>Współpraca z PoS:</strong> Leader schedule (stake‑weighted) działa w ramach osi czasu PoH – wiemy, który slot przypada któremu liderowi bez kosztownej negocjacji.</p><p><strong>Dla Full Stack:</strong> Krótsza latencja widoczna w UX, ale pamiętaj o commitment levels; używaj simulateTransaction + wskaźników slotów do oceny gotowości akcji zależnych (np. claims).</p></div></div>
<div class="qa" id="p7"><div class="q">7) Epoka (epoch) – definicja?</div><div class="simple">Duży rozdział czasu z rozliczeniem nagród.</div><div class="deep"><p><strong>Definicja:</strong> Zbiór kolejnych slotów z góry wyliczonym harmonogramem liderów. Granice epok są punktami rozliczeń i aktualizacji parametrów stake.</p><p><strong>Na granicy epoki:</strong> rozliczenie nagród, aktualizacja effective stake (uwzględnienie warmup/cooldown), odświeżenie leader schedule, ewentualne zmiany parametrów protokołu.</p><p><strong>Implikacje:</strong> Delegacja/dezaktywacja nie działa natychmiast w pełni – wchodzi/wychodzi etapami. Raporty i dashboardy warto bazować na granicach epok (spójność).</p></div></div>
<div class="qa" id="p8"><div class="q">8) Slot i leader?</div><div class="simple">Mini-okienko (≈ ułamek sekundy) dla jednego lidera by dodać blok.</div><div class="deep"><p><strong>Slot:</strong> Okres produkcji bloku. Czas slotu jest krótki (rzędu setek ms) i wynika z parametrów sieci. Każdy slot ma wyznaczonego lidera.</p><p><strong>Leader:</strong> Wyznaczany deterministycznie na podstawie stake (leader schedule). Jeśli lider nie dostarczy bloku (missed slot), sieć przechodzi do kolejnego slotu bez globalnego rollbacku.</p><p><strong>Konsekwencje dla UX:</strong> Sporadyczne luki w blokach nie oznaczają problemu użytkownika – UI powinno tolerować krótkie skoki slotów i bazować na commitment/finality przy prezentacji wyników.</p></div></div>
<div class="qa" id="p9"><div class="q">9) Rola validatora?</div><div class="simple">Pilnuje poprawnych zapisów i dostaje nagrody.</div><div class="deep"><p><strong>Obowiązki:</strong> walidacja i egzekwowanie reguł protokołu, produkcja bloków w slotach lidera, wysyłanie vote transactions, utrzymanie aktualnego ledgeru i snapshotów.</p><p><strong>Jakość operacyjna:</strong> Uptime, przepustowość I/O, prawidłowa konfiguracja sieci (peers), szybkie aktualizacje klienta. Missed votes obniżają nagrody delegatorów.</p><p><strong>Oddzielenie ról:</strong> Walidator ≠ publiczny RPC. Dobre praktyki nakazują separację węzłów wykonywujących ciężkie odczyty (RPC) od węzła konsensusowego.</p></div></div>
<div class="qa" id="p10"><div class="q">10) NRR vs GRR?</div><div class="simple">GRR = brutto, NRR = po prowizji.</div><div class="deep"><p><strong>GRR (Gross Reward Rate):</strong> Teoretyczna stopa zwrotu przed kosztami – uwzględnia inflację, udział w opłatach i potencjalny MEV.</p><p><strong>NRR (Net Reward Rate):</strong> Faktyczny zwrot po potrąceniu prowizji walidatora (commission) i innych kosztów operacyjnych. To na NRR patrzy delegator.</p><p><strong>Praktyka:</strong> NRR = GRR × (1 − commission). Porównując walidatorów, analizuj długoterminowe NRR (uwzględnij missed slots, wahania commission, i stabilność setupu).</p></div></div>
<div class="qa" id="p11"><div class="q">11) MEV podstawy?</div><div class="simple">Zysk z ustawienia transakcji we właściwej kolejności.</div><div class="deep"><p><strong>Definicja:</strong> MEV (Maximal / Miner / Validator Extractable Value) to dodatkowa wartość ekonomiczna możliwa do uzyskania przez kontrolę kolejności, wstawiania, usuwania lub cenzurowania transakcji w bloku/slotach.</p><p><strong>Źródła na Solanie:</strong> arbitraż DEX (Serum/Jupiter), likwidacje pożyczek, reordering swapów, sandwiche (choć trudniejsze przez szybkość), wykorzystanie różnic cen między AMM a order‑book.</p><p><strong>Architektura bez PBS:</strong> Solana nie ma w pełni rozdzielonego „Proposer / Builder” (PBS) – leader kontroluje bundling. Wysoka przepustowość i niska latencja zmniejszają okno reakcji dla botów, ale nie eliminują MEV.</p><p><strong>Detekcja:</strong> Analiza sekwencji instrukcji w slotach, patterny back‑to‑back swapów, anomalia price impact, korelacja z leader identity. Silniki analityczne: strumień logsSubscribe → normalizacja → heurystyki.</p><p><strong>Mitigacje / etyka:</strong> Transparentny raport MEV share do delegatorów, limity manipulacji (policy engine), potencjalne przyszłe wprowadzenie mechanizmów aukcji bundli.</p><p><strong>Dla Full Stack:</strong> Monitoring MEV ↔ estymacja real yield (NRR + MEV component), alerty na nietypowe wzorce w transakcjach użytkownika (np. potencjalne sandwich).</p></div></div>
<div class="qa" id="p12"><div class="q">12) Jak powstaje stake account?</div><div class="simple">Tworzysz specjalne konto na zamrożone SOL.</div><div class="deep"><p><strong>Kroki:</strong> (1) CreateAccount do programu Stake; (2) Initialize z Authorized i Lockup; (3) Delegate do vote account walidatora.</p><p><strong>Struktura danych:</strong> header (authorized staker/withdrawer), optional lockup (unixTimestamp, epoch, custodian), stake state (Inactive/Activating/Active/Deactivating), lamports (saldo + nagrody).</p><p><strong>Warunki:</strong> Rent‑exempt minimalny depozyt; brak możliwości „dobicia” aktywnego konta – tylko nowe konto + merge.</p><p><strong>Błędy częste:</strong> zły programId (nie StakeProgram), brak rent exemption, pomylenie roli authorized (withdrawer ≠ staker), delegate bez inicjalizacji.</p><p><strong>Walidacja aplikacyjna:</strong> Pre-simulate transakcję (simulateTransaction) – sprawdź InstructionError; po sukcesie zapis audytowy (slot, signature, epoch).</p></div></div>
<div class="qa" id="p13"><div class="q">13) Czy delegując tracę kontrolę?</div><div class="simple">Nie – monety dalej Twoje.</div><div class="deep"><p><strong>Własność:</strong> Delegacja przenosi wyłącznie „wagę głosu” (stake weight) do walidatora. Lamports pozostają w Twoim stake account pod withdraw authority.</p><p><strong>Uprawnienia:</strong> Validator nie może wypłacić środków, zmienić authorized ani przekierować stake – brak klucza prywatnego do konta stake.</p><p><strong>Ryzyka realne:</strong> Utrata potencjalnych nagród przy słabym uptime walidatora, wzrost jego komisji, centralizacja (systemic risk) – nie utrata bezpośrednia środków.</p><p><strong>UX / API:</strong> W interfejsie pokaż jasno: saldo dostępne (withdrawable dopiero po deactivate + cooldown) oraz status efektywnej aktywacji.</p></div></div>
<div class="qa" id="p14"><div class="q">14) Dodanie więcej SOL do stake?</div><div class="simple">Robisz drugie konto zamiast dosypywać.</div><div class="deep"><p><strong>Dlaczego brak „top‑up”:</strong> Format stanu stake account nie przewiduje prostej dopłaty zachowującej płynnie jego aktywację.</p><p><strong>Procedura:</strong> Utwórz nowe konto stake (rent‑exempt + kwota) → Initialize → Delegate do tego samego vote account (lub innego) → (opcjonalnie później) merge gdy oba Inactive i zgodne authorized.</p><p><strong>Merge warunki:</strong> Stan docelowy Inactive, ten sam staker i withdrawer, brak lockupu konfliktowego. Po merge lamports sumują się, a footprint (liczba kont) maleje.</p><p><strong>Optymalizacja:</strong> Batch tworzenie wielu kont w jednej transakcji v0 + ALT (redukcja wielkości). Monitoruj liczbę małych kont – zbyt wiele = większy koszt zarządzania.</p></div></div>
<div class="qa" id="p15"><div class="q">15) Compounding nagród?</div><div class="simple">Dostajesz nagrody i możesz je też zablokować.</div><div class="deep"><p><strong>Jak rosną lamports:</strong> Nagrody doliczane są do salda stake account co epokę – brak osobnego „claim”.</p><p><strong>Compounding manualny:</strong> Okresowy split/withdraw nagród (jeśli chcesz je zdywersyfikować) albo po osiągnięciu progu tworzysz nowe konto i delegujesz (reinvest). </p><p><strong>Koszt vs korzyść:</strong> Zbyt częsty compounding = opłaty transakcyjne + dodatkowe rent. Wyznacz próg (np. min % wzrostu lub kwota > rent * X).</p><p><strong>Automatyzacja:</strong> Cron / scheduler monitorujący różnicę lamports vs bazowe saldo, generujący transakcje (create+init+delegate) w oknach niskiego fee.</p><p><strong>Raportowanie:</strong> Wykres kumulacji nagród (net vs gross), wskaźnik efektywności compounding (APR po compounding).</p></div></div>
<div class="qa" id="p16"><div class="q">16) Kryteria wyboru validatora?</div><div class="simple">Stabilny, niska opłata, dobra reputacja.</div><div class="deep"><p><strong>Metryki techniczne:</strong> vote success %, liczba skipped slots, latency produkcji bloków, wersja klienta (aktualność), awarie (crash telemetry).</p><p><strong>Ekonomiczne:</strong> Commission (stabilność, brak nagłych skoków), transparentny podział MEV, historyczne NRR odchyleń.</p><p><strong>Ryzyka:</strong> Centralizacja (zbyt duży udział stake), brak różnorodności geograficznej, brak monitoringu bezpieczeństwa (brak audytów / HSM).</p><p><strong>UX:</strong> Prezentuj walidatory z rankingiem i filtrami (commission, uptime, diversity). Ostrzegaj jeśli validator > określonego % globalnego stake.</p><p><strong>Strategia:</strong> Dywersyfikacja: rozbij stake pomiędzy kilku walidatorów; rotacja słabych performerów po okresie obserwacji (np. 5 epok). Canary test dla nowych walidatorów z małą częścią stake.</p></div></div>
<div class="qa" id="p17"><div class="q">17) Inflacja a APR stakingu?</div><div class="simple">Inflacja = źródło większości nagród.</div><div class="deep"><p><strong>Formuła uproszczona:</strong> APR_net ≈ (inflation_rate × participation_adjust × (1 − commission)) + fees_share + MEV_share.</p><p><strong>Participation adjust:</strong> Jeśli wiele SOL jest stakowane (wysoka partycypacja), nagroda jednostkowa spada – emisja dzieli się na większą bazę.</p><p><strong>Dynamika:</strong> Zmiany parametru inflacji (governance) wpływają na projekcję yield – konieczny moduł forecast w aplikacji.</p><p><strong>Walidacja realnych wyników:</strong> Porównuj rzeczywiste nagrody per epoka z oczekiwaniami modelu; anomalia → problem z walidatorem albo z forecastingiem.</p><p><strong>Prezentacja użytkownikowi:</strong> Rozbij APR na składniki (inflation, fees, MEV). Pokazuj historyczny trend vs obecne parametry sieci.</p></div></div>
<div class="qa" id="p18"><div class="q">18) Priority fees – po co?</div><div class="simple">Płacisz trochę więcej by wejść szybciej.</div><div class="deep"><p><strong>Mechanizm:</strong> Użytkownik może ustawić dodatkową opłatę za compute unit (ComputeBudgetProgram.setComputeUnitPrice). Lider preferuje transakcje o wyższej cenie przy ograniczonych zasobach.</p><p><strong>Cel:</strong> Sygnał wartości (market‑based ordering) twardo konkuruje ze spamem – trudniej floodować sieć bez ponoszenia kosztu.</p><p><strong>UX:</strong> Estymator priority fee (na podstawie ostatnich slotów) – slider/automatyczna rekomendacja. Przy niskim obciążeniu sugeruj minimalny price, przy wysokim – adaptacyjny algorytm (percentile).</p><p><strong>Ryzyka:</strong> Zbyt wysokie opłaty → centralizacja korzyści (boty high‑frequency). Wymagana edukacja użytkownika, by nie przepłacał przy pustych blokach.</p></div></div>
<div class="qa" id="p19"><div class="q">19) Gulf Stream – co to?</div><div class="simple">Transakcje idą naprzód zanim lider je potrzebuje.</div><div class="deep"><p><strong>Idea:</strong> Brak tradycyjnego „global mempool”; transakcje są propagowane i buforowane u przyszłych liderów zanim ich slot nadejdzie.</p><p><strong>Korzyści:</strong> Redukcja latencji (prefetch), mniejsze ryzyko stale rosnącej kolejki, szybsza finalność perceived przez użytkownika.</p><p><strong>Implikacja bezpieczeństwa:</strong> Mniejszy czas na obserwację i reorganizację transakcji → trudniejsze niektóre formy MEV (choć nie znika całkowicie).</p><p><strong>Full Stack:</strong> Możesz szybciej informować użytkownika o „processed” stanie, ale nadal różnicuj UI dla finalized operacji.</p></div></div>
<div class="qa" id="p20"><div class="q">20) Parallelization (TPU)?</div><div class="simple">Robienie wielu kroków naraz jak taśma produkcyjna.</div><div class="deep"><p><strong>Pipeline etapy:</strong> Fetch (odbiór pakietów) → SigVerify (GPU akceleracja podpisów) → Banking (równoległe wykonanie transakcji niekonfliktujących) → PoH record (odcisk czasu) → Broadcast.</p><p><strong>Wymagana struktura:</strong> Model kont (deklaracja zestawu kont w instrukcji) pozwala określić konflikty i wykonywać równolegle nieprzecinające się zestawy.</p><p><strong>Optymalizacja:</strong> Minimalizuj liczbę niepotrzebnych kont w instrukcji (mniejszy graf konfliktów). Batchowanie mikro‑operacji w jednej transakcji zmniejsza overhead podpisu.</p><p><strong>Dla aplikacji:</strong> Projektuj instrukcje o jasno zdefiniowanych zależnościach – unikaj shared mutable big account; używaj PDAs segmentujących stan.</p></div></div>
<div class="qa" id="p21"><div class="q">21) Model accounts vs EVM storage?</div><div class="simple">Dane w osobnych pudełkach zamiast jednego wielkiego magazynu.</div><div class="deep"><p><strong>Solana (accounts model):</strong> Każde konto ma właściciela (programId), określoną <em>wielkość</em> (stałą dopóki nie zrobisz realloc), i lamports (czynsz). Instrukcja deklaruje <em>dokładny</em> zestaw kont (z uprawnieniami: writable/readonly, signer), co pozwala wykryć konflikty i równoległe wykonanie.</p><p><strong>EVM (global storage):</strong> Kontrakt ma globalny storage (mapa slotów) i nie deklaruje zależności w przód – szerokie współdzielenie stanu utrudnia równoległość, wymaga sekwencyjnego przetwarzania lub optymistycznych technik.</p><p><strong>Konsekwencje:</strong> Na Solanie projektuj strukturę danych jako mniejsze konta (PDA per user/market/order), aby zmniejszyć konflikty. Unikaj „wielkiego konta” shared‑state; rozważ sharding po seeds.</p><p><strong>Realloc i rent:</strong> Zmiana rozmiaru konta (realloc) kosztuje (dopłata rent‑exempt). Planuj layouy tak, by minimalizować realloc; rozbij dane na konta o stabilnych rozmiarach.</p><p><strong>UX/Backend:</strong> Klient musi zawsze dostarczyć komplet kont; buduj helpery i cache account metas (np. w SDK), waliduj owner i signer na serwerze zanim zbudujesz transakcję.</p></div></div>
<div class="qa" id="p22"><div class="q">22) Programy BPF?</div><div class="simple">Mini-aplikacje ładowane do sieci.</div><div class="deep"><p><strong>Budowa:</strong> Programy kompilowane do bytecode BPF (np. Rust → LLVM → BPF), wykonywane w sandboxie runtime Solany. Brak dostępu do systemu plików/sieci, deterministyczne wykonywanie, brak RNG poza dostarczonym przez program lub konto.</p><p><strong>Limity:</strong> Compute Units (CU) per instrukcja/transakcja, rozmiar danych wejściowych, brak alokacji dynamicznej poza dozwolonymi buforami. Każdy dostęp do konta musi być zadeklarowany w message.</p><p><strong>Wydajność:</strong> Minimalizuj kopie buforów (serde), używaj zero‑copy (np. bytemuck/POD), układaj struktury liniowo. Unikaj pętli zależnych od danych użytkownika bez twardych limitów.</p><p><strong>Upgrade:</strong> Program może mieć upgrade authority – trzymaj ją w HSM lub zrzeknij się po stabilizacji (immutable code). Migracje stanu: dodawaj pola wstecznie kompatybilnie, wersjonuj layout.</p></div></div>
<div class="qa" id="p23"><div class="q">23) Anchor – zalety?</div><div class="simple">Framework który upraszcza pisanie programów.</div><div class="deep"><p><strong>Co daje:</strong> IDL (Interfejs) generowany z kodu, makra walidujące konta (has_one, owner, signer), deklaratywny layout, automatyczne CPI helpery, testy z lokalnym validator.</p><p><strong>Bezpieczeństwo:</strong> Mniej boilerplate → mniejsze ryzyko pominięcia walidacji signer/owner. Guards (constraints) są czytelne i audytowalne.</p><p><strong>Migracje:</strong> Versioning kont (discriminant + wersja), opcja dodawania pól z defaultami; procedury „upgrade” z migracją danych i kontrolą kosztu CU.</p><p><strong>SDK:</strong> Klienci (TS) generowani z IDL – mniej błędów w budowaniu instrukcji, lepsze DX.</p><p><strong>Pułapki:</strong> Nadmierna abstrakcja ukrywa szczegóły CU i rozmiarów; w krytycznych ścieżkach profiluj i czasem schodź niżej (native web3). </p></div></div>
<div class="qa" id="p24"><div class="q">24) Typowe luki bezpieczeństwa?</div><div class="simple">Złe sprawdzanie kto może co zrobić.</div><div class="deep"><p><strong>Autoryzacja:</strong> Brak sprawdzenia, że wymagane konto jest signerem; mylenie owner (programId) konta danych; brak kontroli seeds dla PDA (kolizje/nadmierne uprawnienia).</p><p><strong>Serializacja:</strong> Niebezpieczne deserializacje (brak sprawdzenia długości/bounds), zaufanie do danych użytkownika bez walidacji typów i zakresów.</p><p><strong>Reentrancy/State:</strong> Nie ma klasycznej reentrancy jak w EVM, ale złe założenia o atomowości i kolejności CPI mogą prowadzić do wyścigów. Zawsze waliduj stan kont tuż przed mutacją.</p><p><strong>Integery:</strong> Over/underflow przy arytmetyce lamports lub indeksach buforów – używaj checked ops.</p><p><strong>Upgrade authority:</strong> Niechronione klucze do upgrade → przejęcie programu. Przeniesienie do HSM lub zrzeknięcie po audycie.</p><p><strong>Obrona:</strong> Listy kontrolne, testy fuzz, property‑based tests, ograniczenia (constraints) Anchor, audyty zewnętrzne.</p></div></div>
<div class="qa" id="p25"><div class="q">25) Fuzz testing rola?</div><div class="simple">Automatyczne losowe testy szukające dziur.</div><div class="deep"><p><strong>Cel:</strong> Wykrywać panics, invariants violations, nieoczekiwane ścieżki stanów poprzez generowanie losowych sekwencji instrukcji i danych.</p><p><strong>Narzędzia:</strong> cargo‑fuzz, proptest/quickcheck (property‑based). Dla Anchor – harness, który serializuje instrukcje według IDL i tworzy losowe konta (PDA) z poprawnymi seeds.</p><p><strong>Zakres:</strong> Granice buforów, wartości minimalne/maksymalne, konfliktujące konta, CPI kombinacje, ataki na lockup/authorize.</p><p><strong>Integracja CI:</strong> Krótsze kampanie w PR, dłuższe nocne/regresyjne. Zbieraj coverage i panele crashy (stacktrace + hexdump wejścia).</p></div></div>
<div class="qa" id="p26"><div class="q">26) Mosty (bridges) – cel?</div><div class="simple">Przenoszą wartość między łańcuchami.</div><div class="deep"><p><strong>Mechaniki:</strong> Lock & mint (zablokuj źródłowe, emituj reprezentację) lub burn & release (spal reprezentację, uwolnij źródłowe). </p><p><strong>Modele zaufania:</strong> custodial/multi‑sig (guardianzy zatwierdzają), light‑client (on‑chain weryfikacja nagłówków obcej sieci), optimistic (okno wyzwań). </p><p><strong>Ryzyka:</strong> Kompromitacja guardianów, błędy w implementacji (serialization/verification), depeg ekonomiczny. </p><p><strong>Praktyka:</strong> Dywersyfikuj mosty, monitoruj TVL i opóźnienia, stosuj limity transferów i alerty health. W UI pokazuj status mostu i ostrzeżenia o ryzyku.</p></div></div>
<div class="qa" id="p27"><div class="q">27) Ryzyka cross-chain?</div><div class="simple">Jeśli most zepsuty – token fałszywy.</div><div class="deep"><p><strong>Techniczne:</strong> Replay/relay błąd, niekompletna weryfikacja dowodów, błędny parser nagłówków, brak timeouts. </p><p><strong>Ekonomiczne:</strong> Depeg wrapped assets, niedopasowanie płynności, ataki na wycenę (oracle) i wywołanie masowych redeemów.</p><p><strong>Operacyjne:</strong> Single‑points‑of‑failure (guardian), brak transparentnych audytów, opóźnienia aktualizacji po incydentach.</p><p><strong>Mitigacje:</strong> Limity dzienne, listy dozwolonych kierunków, dodatkowa weryfikacja po stronie backend (multi‑source oracles), alerty na anomalia wolumenów.</p></div></div>
<div class="qa" id="p28"><div class="q">28) Rent w Solanie?</div><div class="simple">Mała opłata za trzymanie danych alive.</div><div class="deep"><p><strong>Model:</strong> Konta wymagają depozytu rent‑exempt (próg zależny od rozmiaru), aby nie podlegać czyszczeniu. </p><p><strong>Projektowanie:</strong> Minimalizuj rozmiary kont (POD/kompaktowe layouty), unikaj częstego realloc, recyklinguj istniejące konta zamiast tworzyć nowe (zachowując owner).</p><p><strong>Operacje:</strong> Przy zwiększeniu rozmiaru – dopłać różnicę rent. Przy zwolnieniu pamięci rozważ migrację do mniejszego konta i merge.</p><p><strong>UX:</strong> Pokazuj użytkownikowi koszt rent podczas tworzenia kont (np. stake, mint, PDA) i ostrzegaj przy braku progu.</p></div></div>
<div class="qa" id="p29"><div class="q">29) Różnica validator vs dedicated RPC?</div><div class="simple">Validator waliduje, RPC podaje dane aplikacjom.</div><div class="deep"><p><strong>Validator:</strong> Uczestniczy w konsensusie, produkuje bloki, głosuje, utrzymuje ledger. Krytyczny element bezpieczeństwa – izoluj go od ciężkich zapytań.</p><p><strong>RPC:</strong> Węzły nastawione na odczyty/zapisy dla aplikacji: load‑balancing, cache, indeksy (np. Geyser plugins), rate‑limiting i QoS. </p><p><strong>Najlepsze praktyki:</strong> Oddziel sieciowo, inny sprzęt/region; monitoruj p95/p99 latencje, limity QPS. W scenariuszu enterprise – mTLS i whitelisty.</p></div></div>
<div class="qa" id="p30"><div class="q">30) Indeksowanie danych?</div><div class="simple">Tworzenie szybkiej wyszukiwarki zdarzeń.</div><div class="deep"><p><strong>Pipeline:</strong> block/transaction stream (WS + backfill REST) → parser instrukcji (program taxonomy, ABI/IDL) → normalizacja (schemat zdarzeń) → magazyny: OLTP (Postgres) + OLAP (ClickHouse) + TSDB (Timescale).</p><p><strong>Spójność:</strong> Idempotentny ETL (upsert po signature+index), resume od ostatniego slotu, detekcja reorg (porównanie parentSlot/slot).</p><p><strong>Wydajność:</strong> Batch insert, partycjonowanie po czasie/slotach, indeksy na (programId, account, slot). Redis jako hot cache. </p><p><strong>Backfill:</strong> Snapshot + incremental ingest; throttling by nie przeciążać RPC. Monitoruj lag indeksowania i zapewnij wskaźnik „data freshness” w API.</p></div></div>
<div class="qa" id="p31"><div class="q">31) Realtime dashboard architektura?</div><div class="simple">Aktualizuje się na żywo bez odświeżania.</div><div class="deep"><p><strong>Cel:</strong> Niskolatencyjna wizualizacja slotów, transakcji, nagród, zdrowia walidatora i metryk systemowych bez ręcznego odświeżania.</p><p><strong>Strumień danych:</strong> WebSocket (subskrypcje: slot, logs, signatures) + Geyser plugin (Kafka/GRPC) → kolejka (Kafka) → procesory (Flink / Spark Streaming) do wzbogacania i agregacji (rolling windows, tumbling windows).</p><p><strong>Magazyny:</strong> TSDB (Timescale/Influx) dla metryk, OLAP (ClickHouse) dla zapytań analitycznych, Redis jako hot cache (ostatnie N sekund slotów, top walidator latency).</p><p><strong>API warstwa:</strong> GraphQL (federacja: realtime + history) lub REST + SSE/WS. Mechanizm re-connect z ack ostatniego slotu (resume). Backpressure: ogranicz liczbę aktywnych kanałów per użytkownik.</p><p><strong>Front-end:</strong> React z ECharts / D3: wirtualizacja tabel (thousands rows), incremental updates (diff patch), time shift panel (śledzenie trendu). Stany: live, paused (history scroll), compare (epoka vs epoka).</p><p><strong>Performance:</strong> Downsampling (1s → 5s → 60s) wg zoom level; compression (binary msgpack) zamiast JSON dla gęstych kanałów. CDN dla statycznych assetów.</p><p><strong>Observability:</strong> Lag (producer ts vs client render ts), drop rate, CPU aggregator. Alert jeśli lag > X ms przez Y sek. </p><p><strong>Bezpieczeństwo:</strong> Rate limit subskrypcji, auth token w handshake, izolacja kanałów prywatnych (delegator rewards) od publicznych.</p></div></div>
<div class="qa" id="p32"><div class="q">32) Kluczowe metryki monitoringu?</div><div class="simple">Czy działa szybko i bez przerw.</div><div class="deep"><p><strong>Walidator:</strong> vote success %, skipped slots, block production latency (leader slot start → block broadcast), snapshot age (czas od ostatniego pełnego snapshotu), fork divergence (różnica względem majority tip).</p><p><strong>RPC:</strong> p50/p95/p99 GET balance/transaction latency, error rate (InstructionError / BlockhashNotFound), WebSocket reconnect frequency.</p><p><strong>System:</strong> CPU (user/sys), disk IO wait, network throughput (ingress/egress), memory pressure (account cache hit rate).</p><p><strong>Aplikacja staking:</strong> reward calculation duration per epoch, indexing lag (slots behind), queue depth (pending operations), compounding scheduler success.</p><p><strong>SLA/KPIs:</strong> finality time (processed→finalized delta), mean time between missed slots, validator health score (weighted composite).</p><p><strong>Alerty:</strong> Vote success % < threshold, snapshot age > max, indexing lag > N slots, sudden commission change. </p><p><strong>Instrumentacja:</strong> Prometheus exporters + OpenTelemetry traces (ingest pipeline). Correlation-id nazwana w logach ws.</p></div></div>
<div class="qa" id="p33"><div class="q">33) Wysoka dostępność (HA)?</div><div class="simple">Zapasowy serwer czeka gotowy.</div><div class="deep"><p><strong>Model:</strong> Primary validator + shadow (standby) utrzymujący aktualny ledger (regularne snapshot sync + incremental replay). Separacja dostawców (multi-cloud / bare metal mix).</p><p><strong>Switchover:</strong> Health controller monitoruje slot progress, vote submission; jeśli stagnacja > X sek lub krytyczne błędy I/O → orchestrated failover (stop primary, promote standby).</p><p><strong>Ryzyko double-sign:</strong> Sekwencyjne wyłączanie (graceful shutdown + key lock). Audit log czasu operacji failover.</p><p><strong>Konfiguracje:</strong> Idempotentny provisioning (Ansible/Terraform), template symlink dla wersji binarek, canary upgrade na shadow przed mass rollout.</p><p><strong>Testy:</strong> Chaos drills (symuluj sieć partition, disk full), RPO/RTO pomiary (czas od awarii do powrotu głosowania).</p></div></div>
<div class="qa" id="p34"><div class="q">34) Failover szczegóły?</div><div class="simple">Automatyczne przełączenie gdy główny śpi.</div><div class="deep"><p><strong>Detekcja:</strong> Watchdog: brak wzrostu slot, brak nowych vote tx, wysokie error rate RPC health. Multi-signal aby uniknąć fałszywych przełączeń.</p><p><strong>Kroki:</strong> (1) Mark primary unhealthy; (2) stop produkcji (drain), (3) ensure last vote emitted, (4) unlock promotion flag, (5) start standby z identity keys (lub rotate jeśli polityka bezpieczeństwa), (6) sanity self-test.</p><p><strong>Logowanie:</strong> Strukturalne eventy: failover_initiated, failover_completed, root_slot_at_switch. Chronologiczne timeline dla audit.</p><p><strong>Edge cases:</strong> Split brain (network partition) – quorum check przed promocją; delayed snapshots – wymuś szybki catch-up z incremental snapshots.</p><p><strong>Monitoring:</strong> Post-mortem generator automatycznie z logów i metryk.</p></div></div>
<div class="qa" id="p35"><div class="q">35) Zarządzanie kluczami?</div><div class="simple">Klucze trzymane bardzo bezpiecznie.</div><div class="deep"><p><strong>Generacja:</strong> Air‑gapped (offline) device, deterministyczne seed phrase w sejfie, HSM dla produkcyjnego podpisu (vote, upgrade authority). </p><p><strong>Przechowywanie:</strong> Szyfrowanie at rest (KMS), podział ról: brak pojedynczego operatora z pełnym dostępem (M-of-N procedury).</p><p><strong>Rotacja:</strong> Okna maintenance: wyprzedzająca aktualizacja secondary keys, test podpisu, potem aktywacja. Dokumentacja wersji i daty ważności.</p><p><strong>Audyt:</strong> Immutable log (append-only) operacji podpisu krytycznych (program upgrade, autorization changes). Reakcja na anomalię: automatyczne zawieszenie operacji high-risk.</p><p><strong>Komponenty:</strong> Vault (secret management), HSM cluster (redundancja), monitoring integritetu (tamper detection).</p></div></div>
<div class="qa" id="p36"><div class="q">36) Slashing obecnie?</div><div class="simple">Głównie tracisz nagrody jeśli źle działasz.</div><div class="deep"><p><strong>Stan dziś:</strong> Brak szerokiego slashing jak w niektórych PoS – główny koszt to utrata potencjalnych nagród (missed votes, downtime).</p><p><strong>Potencjalne przyszłe kierunki:</strong> Mechanizmy kar za malicious double vote / equivocating, wykrywanie celowej cenzury.</p><p><strong>Znaczenie dla delegatora:</strong> Ocena walidatora bardziej skupiona na uptime i consistency niż ryzyku konfiskaty stake, ale warto śledzić ewolucję protokołu.</p><p><strong>Przygotowanie:</strong> Budowa telemetry i alertów już teraz ułatwia adaptation gdy slashing zostanie rozszerzony.</p></div></div>
<div class="qa" id="p37"><div class="q">37) Detekcja MEV?</div><div class="simple">Patrzymy które transakcje dały extra zysk.</div><div class="deep"><p><strong>Dane wejściowe:</strong> Strumień instrukcji DEX, ceny (oracle feed), order flow sekwencje.</p><p><strong>Heurystyki:</strong> Back‑to‑back token A→B→A z dodatnim delta, likwidacje z wyprzedzeniem, sandwich (pre-swap + victim swap + post-swap). Bloom filtry do szybkiego wstępnego oznaczania.</p><p><strong>Wycena:</strong> Symulacja stanu przed/po zestawie instrukcji; różnica netto wartości portfela operatora. </p><p><strong>Raportowanie:</strong> Dashboard slot→MEV value, mapowanie leader ID, share do delegatorów. Merkle root dystrybucji dla weryfikowalności.</p><p><strong>Mitigacje:</strong> Policy engine – odrzucanie wzorców ekstremalnego frontrunningu lub sygnalizowanie użytkownikowi.</p></div></div>
<div class="qa" id="p38"><div class="q">38) API staking – design?</div><div class="simple">Jedno API do wielu sieci.</div><div class="deep"><p><strong>Warstwy:</strong> Edge (Gateway: auth, rate limit), Orchestrator (adaptery chain-specific), Ops DB (operations table), Workers (async job queue), Indexer (reward/state sync).</p><p><strong>Endpointy:</strong> POST /stake (create+delegate), POST /unstake, GET /rewards?epoch=, GET /validators, POST /compound, GET /operations/{id} (status). Idempotency-Key w nagłówku.</p><p><strong>Model operacji:</strong> Async: operation_id + status (pending, submitting, finalized, failed). Retry polityka z backoff (blockhash expiry).</p><p><strong>Error model:</strong> problem+json (type, title, detail, instance, code). Mapowanie InstructionError -> semantyczne kody.</p><p><strong>Bezpieczeństwo:</strong> HMAC podpis dla mutacji (payload canonical), JWT scopes (stake:write), audit trail (who, when, slot).</p><p><strong>Observability:</strong> correlation-id przez łańcuch logów + trace span per step (build tx, simulate, submit, confirm).</p></div></div>
<div class="qa" id="p39"><div class="q">39) Autoryzacja API?</div><div class="simple">Klucz który mówi że to Ty.</div><div class="deep"><p><strong>Warstwy:</strong> API Key (static identity + scopes), JWT (short-lived session), HMAC (integrity + replay protection), opcjonalnie mTLS (cert mutual) dla enterprise.</p><p><strong>Flow:</strong> Klient używa API Key do uzyskania JWT (Auth server). Mutacje: body + timestamp + nonce → HMAC(key) → nagłówki <em>X-Signature</em>, <em>X-Timestamp</em>. Serwer waliduje okno czasu i brak powtórki nonce (Redis).</p><p><strong>Scopes:</strong> read:rewards, write:stake, admin:validators. Least privilege – odcinaj możliwość create stake w kluczach tylko do odczytu.</p><p><strong>Rotacja:</strong> Dwufazowa (stary + nowy równolegle), automatyczne wygaszenie starego po okresie grace.</p></div></div>
<div class="qa" id="p40"><div class="q">40) Rate limiting & QoS?</div><div class="simple">Limit aby nikt nie zajął całego miejsca.</div><div class="deep"><p><strong>Mechanizmy:</strong> Token bucket (req/s), leaky bucket (smooth), concurrency limiter (maks aktywnych mutacji), dynamic shaping wg CPU/RPC latency.</p><p><strong>QoS klasy:</strong> tier enterprise (większe limity + priority compute budget), standard, public. Weighted fair queue – zapobieganie monopolizacji.</p><p><strong>Ochrona RPC:</strong> Circuit breaker: jeśli p95 latency > threshold → throttle nowych preflight. Backoff globalny redukuje burst.</p><p><strong>Feedback:</strong> Nagłówki: Retry-After, RateLimit-Remaining, RateLimit-Reset. Event „throttled” w logach z correlation-id.</p><p><strong>Tuning:</strong> Automatyczne dostosowanie limitów na podstawie history usage i godzin szczytu (predictive).</p></div></div>
<div class="qa" id="p41"><div class="q">41) Widget stakingowy – bezpieczeństwo?</div><div class="simple">Nie trzyma Twoich kluczy, tylko prosi portfel o podpis.</div><div class="deep"><p><strong>Model architektury:</strong> Osadzony widget (iframe) w zewnętrznych stronach partnerów deleguje interakcje z łańcuchem do kontrolowanego origin. Brak dostępu do kluczy prywatnych – portfel (Phantom/Ledger) podpisuje.</p><p><strong>Izolacja:</strong> <code>iframe sandbox="allow-scripts allow-popups"</code>, brak <code>allow-same-origin</code> (uniemożliwia odczyt localStorage hosta). <strong>CSP:</strong> <code>default-src 'none'; script-src 'self'; connect-src https://api.example.com wss://ws.example.com; frame-ancestors 'none';</code> – prevents injection & click‑jacking.</p><p><strong>Komunikacja:</strong> <code>postMessage</code> z walidacją źródła i typów (schema JSON + strict allowlist eventów: INIT, BUILD_TX, SIGN_RESULT). Ignoruj nieznane eventy, limit długości payload.</p><p><strong>Walidacja danych:</strong> Po stronie iframe: typy, zakresy (stakeQty > 0, <= max), sprawdzony validator pubkey (lista dozwolonych). Na backend: ponowna walidacja (never trust client), signature check, rate limit per delegator.</p><p><strong>Anty‑phishing:</strong> Wyraźny indicator (mini banner „Powered by ...”) + host allowed domains registry (odrzucenie osadzenia na nieautoryzowanym origin z logiem audytowym).</p><p><strong>Telemetry & prywatność:</strong> Zanonimizowane eventy (hash delegator pubkey salted ephemeral), slot latency, error code. Brak surowych kluczy lub kwot w logach debug – używaj bucketization.</p><p><strong>Edge cases:</strong> Przerwane połączenie portfela – widget pokazuje „Reconnect”. Próba podpisu transakcji spoza dopuszczonego seed/validator – blokada i alert. Wstrzyknięcie skryptu – CSP blokada + raport <code>report-to</code>.</p></div></div>
<div class="qa" id="p42"><div class="q">42) Integracja Phantom?</div><div class="simple">Klik i zgoda w oknie portfela.</div><div class="deep"><p><strong>Flow:</strong> (1) Detection <code>window.solana?.isPhantom</code>; (2) <code>await window.solana.connect()</code> (przyznanie publicKey); (3) Pobierz <code>latestBlockhash</code>; (4) Zbuduj instrukcje (stake create/delegate); (5) Opcjonalna symulacja <code>simulateTransaction</code> (wykrycie błędów, CU usage); (6) <code>signAndSendTransaction</code> lub <code>signTransaction</code> + własne <code>sendRawTransaction</code>; (7) Poll lub subskrypcja <code>signature</code> do <code>finalized</code>.</p><p><strong>UX:</strong> Loading state podczas generowania blockhash, fallback przy <code>BlockhashNotFound</code> (fetch nowy i re‑sign). Wyraźny komunikat co jest podpisywane (ilość SOL, opłaty, validator).</p><p><strong>Błędy:</strong> Użytkownik anuluje ↔ rozróżniaj <code>UserRejected</code> vs transport. Retry logic tylko dla transient (network). Przy durable nonce – pobierz i dołącz advanceNonce instrukcję.</p><p><strong>Bezpieczeństwo:</strong> Nigdy nie wysyłaj surowej seed phrase. Validate, że fee payer = użytkownik (lub jasno opisz jeśli sponsor). Sprawdź <code>publicKey</code> konsystencję między krokami (race condition tab reload).</p><p><strong>Observability:</strong> Log (correlationId, signature, slot finalization delta). Analiza p95 czasu od connect → finalized (benchmark UX).</p></div></div>
<div class="qa" id="p43"><div class="q">43) Ledger integracja?</div><div class="simple">Fizyczne urządzenie zatwierdza podpis.</div><div class="deep"><p><strong>Transport:</strong> WebUSB (Chrome) lub HID (fallback). Wykrycie urządzenia → open channel → apdu exchange.</p><p><strong>Derivation path:</strong> Standard <code>44'/501'/0'/0'</code> (Solana). Multi‑account: iteracja indeksu. Prezentuj adres skrócony i ikonę (checksum) by uniknąć spoof.</p><p><strong>Partial signing:</strong> W transakcjach multi‑sig: zbierasz podpis Ledger, dołączasz pozostałe (np. z backend sponsor) → finalny send.</p><p><strong>Wielkość transakcji:</strong> Dziel duże transakcje (instrukcje) jeśli przekracza limit APDU; preferuj ALT by skrócić listę kont przed wysłaniem do urządzenia.</p><p><strong>UX:</strong> Kroki progresu: „Czekam na urządzenie” → „Potwierdź na Ledger” → success/fail. Timeout detection (device idle). Fallback: instrukcja enabling WebUSB.</p><p><strong>Błędy:</strong> Device locked, stale app version (wyświetl wymagane minimum), APDU parsing error – zgłoś jasny komunikat + link do troubleshoot.</p><p><strong>Bezpieczeństwo:</strong> Nie buforuj prywatnych danych – Ledger przechowuje klucze. Waliduj że wysyłana wiadomość jest final (brak mutacji po podpisie). Integrity hash w UI.</p></div></div>
<div class="qa" id="p44"><div class="q">44) Strategia compounding?</div><div class="simple">Odkładasz nagrody w nowe konto regularnie.</div><div class="deep"><p><strong>Determinacja progu:</strong> Modeluj ROI vs koszt: próg = min lamports gdzie (dodatkowy APR z reinwestycji − fee − rent amortized) > 0. Możesz użyć dynamicznego progu zależnego od fee p95.</p><p><strong>Algorytm:</strong> Co epokę: oblicz wzrost salda stake vs baza; jeśli > próg → split + create delegate nowego konta lub withdraw + batch tworzenie. Grupy transakcji w oknie niskiego obciążenia (sloty nocne regionu).</p><p><strong>Optymalizacja:</strong> Użyj transakcji v0 + ALT by zamknąć operacje w 1–2 transakcjach. Simuluj i dostosuj compute units price tylko jeśli backlog wysoki.</p><p><strong>Monitoring:</strong> Metryka „compounding efficiency” (rzeczywisty APR/net vs teoretyczny). Alerty gdy brak compounding > X epok mimo przekroczonego progu.</p><p><strong>Edge cases:</strong> Małe konta generujące więcej opłat niż zysk – automatyczna konsolidacja (merge Inactive).</p></div></div>
<div class="qa" id="p45"><div class="q">45) Raport nagród delegatora?</div><div class="simple">Tabela ile zarobiłeś co epokę.</div><div class="deep"><p><strong>Źródła:</strong> On-chain epoch reward kalkulacje (stake balance delta), commission walidatora, MEV share, fees share.</p><p><strong>ETL kroki:</strong> (1) Pobierz listę stake kont delegatora; (2) Dla każdej epoki: saldo startowe vs końcowe; (3) Odzyskaj commission history; (4) Oblicz gross (przed commission), net, NRR.</p><p><strong>Schema:</strong> <code>rewards(epoch, delegator, validator, gross_lamports, commission_pct, commission_lamports, net_lamports, mev_component, fees_component, nrr_pct)</code>.</p><p><strong>Walidacja:</strong> Suma net wszystkich delegatorów ≈ global distributed rewards (tolerancja rounding). Drift alert jeśli różnica > epsilon.</p><p><strong>Prezentacja:</strong> Trend + breakdown stacked (inflation vs MEV vs fees), porównanie walidatorów. Eksport CSV/JSON signed (integrity hash).</p><p><strong>Edge:</strong> Zmiana validator commission mid‑epoch – przypisuj wg czasu aktywacji. Merge/split – śledź lineage kont (parent/child) dla agregacji.</p></div></div>
<div class="qa" id="p46"><div class="q">46) Podział MEV dla delegatorów?</div><div class="simple">Dodatkowy bonus dzielony proporcjonalnie.</div><div class="deep"><p><strong>Proces:</strong> W trakcie epoki agregujesz wartości zidentyfikowanych MEV transakcji (po walidacji heurystykami & manual sample). Operator fee / cut odejmowany.</p><p><strong>Formuła:</strong> <code>alloc = floor( (delegator_effective_stake / total_effective_stake) * mev_pool_lamports )</code>. Reszta (dust) może zostać dołączona losowo lub przeniesiona do następnej puli.</p><p><strong>Transparentność:</strong> Publikacja raportu JSON + Merkle tree (leaf: delegator_pubkey + amount). Umożliwia niezależną weryfikację rozdziału.</p><p><strong>Bezpieczeństwo:</strong> Anti‑gaming: wykrywanie sztucznych mikro stake kont tworzonych tuż przed końcem epoki (minimalny czas aktywacji wymagany). Audit log kalkulacji.</p><p><strong>UX:</strong> Pokaż spodziewany komponent MEV w APR (prognoza) + real po epokach. Tooltip objaśniający heurystyki detekcji.</p></div></div>
<div class="qa" id="p47"><div class="q">47) Klientowa różnorodność?</div><div class="simple">Różne wersje oprogramowania zmniejszają wspólne błędy.</div><div class="deep"><p><strong>Cel:</strong> Zmniejszyć ryzyko jednolitej awarii (single critical bug) i zwiększyć odporność na ataki celujące w konkretny kod path.</p><p><strong>Strategia wdrożeń:</strong> Canary (mały % stake) na najnowszą wersję → obserwacja metryk (vote success, crash rate) → stopniowy rollout. Utrzymuj co najmniej 2 stabilne gałęzie przez przejściowe okno.</p><p><strong>Monitoring:</strong> Crash telemetry per version, divergence w slot progress, security patch adoption time (SLO). Alert gdy >X% stake na jednej build w zbyt długim okresie.</p><p><strong>Dokumentacja:</strong> Public dashboard wersji vs udział stake – zachęca do równowagi. Polityka EOL.</p><p><strong>Edge:</strong> Zbyt wiele wersji utrudnia wsparcie – limit aktywnych do N, starsze z migracją planem.</p></div></div>
<div class="qa" id="p48"><div class="q">48) Multi-region design?</div><div class="simple">Serwery w kilku miejscach na świecie.</div><div class="deep"><p><strong>Architektura:</strong> API warstwa stateless (kontenery / serverless) aktywna we wszystkich regionach. State: Postgres (logical replication), ClickHouse (replicated shards), Redis (geo-distributed multi-primary z konflikt polityką last-write-wins dla ephemeral cache).</p><p><strong>Routing:</strong> GeoDNS/Anycast → najbliższy region. Health-based failover: jeśli region latency / error rate > threshold, dynamic weight = 0.</p><p><strong>Snapshot dystrybucja:</strong> Walidator snapshoty push do object storage (S3/GCS) → CDN edge accelerate pobieranie dla shadow nodes.</p><p><strong>DR parametry:</strong> RPO < 15m (binlog shipping), RTO < 60m (infra automation + warm standby). Regularne testy przełączeń (game day).</p><p><strong>Dane wrażliwe:</strong> Klucze HSM tylko w regionach primary (brak private material w secondary do czasu promocji).</p><p><strong>Observability:</strong> Region tags w metrykach/traces; panel porównujący p95 latency per region.</p></div></div>
<div class="qa" id="p49"><div class="q">49) SOC2 / compliance elementy?</div><div class="simple">Dowody, że działasz bezpiecznie i przewidywalnie.</div><div class="deep"><p><strong>Kluczowe domeny:</strong> Security, Availability, Confidentiality, Processing Integrity.</p><p><strong>Kontrole:</strong> Regular access reviews (IAM diff raport), change management (ticket + peer review + CI artifact hash), incident response playbooks (MTTA/MTTR metryki), immutable audit log (append-only + WORM storage).</p><p><strong>Dane:</strong> Szyfrowanie TLS in-transit, AES-256 at-rest, secret rotation (30d), segregacja środowisk (prod vs staging).</p><p><strong>Vulnerability mgmt:</strong> Skany SCA + zależności (SBOM), patch SLO (krytyczne < 7d). Bug bounty integracja.</p><p><strong>Backup:</strong> Test restore quarterly; raport potwierdzający integralność (checksum). Drift detection konfiguracji.</p><p><strong>Ewidencja:</strong> Artefakty (policy docs, risk register, control evidence) automatycznie export do compliance portal.</p></div></div>
<div class="qa" id="p50"><div class="q">50) System design platformy 10B+ TVL?</div><div class="simple">Warstwy które bezpiecznie obsługują dużo pieniędzy.</div><div class="deep"><p><strong>Warstwy logiczne:</strong> Edge (API Gateway + WAF) → Auth/Rate → Orchestrator (multi-chain adapters) → Domain services (Staking, Rewards, MEV, Portfolio) → Reporting/Analytics.</p><p><strong>Dane:</strong> OLTP Postgres z partycjonowaniem (delegator_id, epoch), OLAP ClickHouse dla agregacji (materialized views), Redis cluster (hot keys: delegator balance, validator health), Object Storage (snapshots, exports, Merkle proofs).</p><p><strong>Skalowanie:</strong> Idempotentne mikrousługi (replay safe), event sourcing dla krytycznych (stake ops). Backpressure poprzez kolejki (Kafka) – każdy serwis konsumuje we własnym tempie.</p><p><strong>Bezpieczeństwo:</strong> HSM dla kluczy upgrade authority, least privilege IAM, continuous secret rotation, anomaly detection (nagłe wzrosty unstake).</p><p><strong>Observability:</strong> Correlation-id end-to-end, tracing (ingest→calc→API), SLO dashboards (latency, error %, freshness lag). Chaos drills: symulacja region outage, walidatora degradacji.</p><p><strong>Reziliencja:</strong> Active-active multi-region, automatyczny failover DB (patroni/managed), circuit breakers na zewnętrzne RPC, degrade do read-only trybu przy poważnej awarii części systemu.</p><p><strong>Zarządzanie kosztami:</strong> Downsampling metryk historycznych, archiwizacja starych epok do cold storage, autoscaling workerów dynamicznie wg ops queue depth.</p><p><strong>Compliance:</strong> Audit log + narzędzie do szybkiego generowania zestawów dowodów (SOC2). Data retention polityka (program state vs user analytics).</p></div></div>
<!-- End QAs -->
<h2>Szybka ściąga (Flashcards)</h2><div class="cluster"><span class="tag">PoH=Zegar kryptograficzny</span><span class="tag">Slot≈400ms</span><span class="tag">NRR=Net</span><span class="tag">MEV=Order Value</span><span class="tag">Stake Account Immutable Size</span><span class="tag">Merge Stake</span><span class="tag">Rent-exempt</span><span class="tag">Gulf Stream=No mempool</span><span class="tag">TPU Pipeline</span><span class="tag">Anchor IDL</span><span class="tag">Fuzz Security</span><span class="tag">Canary Upgrades</span><span class="tag">HSM Keys</span><span class="tag">Kafka/Flink Stream</span><span class="tag">ClickHouse OLAP</span><span class="tag">Redis Hot Cache</span></div>

<h2>Dodatkowe pytania (Full‑Stack Deep Dive)</h2>

<div class="qa" id="p51"><div class="q">51) Transaction v0 i Address Lookup Tables (ALT)?</div><div class="simple">Nowy format transakcji, który pozwala skrócić adresy przez tablice – dzięki temu mieszczą się większe operacje.</div><div class="deep"><p><strong>Motywacja:</strong> Ograniczyć rozmiar wiadomości przy dużej liczbie kont (DEX, staking batch). ALT przechowuje listę adresów; transakcja v0 zawiera indeksy zamiast pełnych kluczy.</p><p><strong>Lifecycle ALT:</strong> create (inicjalny owner), extend (dodawanie nowych adresów – limit), freeze/deactivate (opcjonalne). Monitoruj pełność (capacity remaining).</p><p><strong>Frontend:</strong> Zbierz wymagane konta → rozdziel na immediate i ALT referencje → <code>compileToV0Message</code>. Weryfikuj, że wszystkie ALT konta dostępne (prefetch). Fallback: jeśli ALT brakuje konta → degradacja do legacy (o ile mieści się).</p><p><strong>Backend:</strong> Cache ALT w pamięci (TTL + slot wersja). Waliduj integralność (hash zawartości) co jakiś czas. Migracje: nowa ALT gdy stara pełna; mapowanie wersji w DB.</p><p><strong>Edge cases:</strong> Nieaktualny stan ALT (race extend) – preflight z <code>maxSupportedTransactionVersion</code> i retry fetch. Usunięte/kupione konta w ALT – walidacja owner przed użyciem.</p><p><strong>Security:</strong> Kontrola dostępu do extend (authority). Audyt zmian – loguj stare vs nowe listy.</p></div></div>

<div class="qa" id="p52"><div class="q">52) Durable Nonce i wygaśnięcie blockhasha?</div><div class="simple">Zapasowy stempel czasu, żeby transakcja nie wygasła za szybko.</div><div class="deep"><p><strong>Problem:</strong> Standardowy blockhash wygasa (~2 min). Długie ścieżki podpisu (HSM, hardware wallets) ryzykują <code>BlockhashNotFound</code>.</p><p><strong>Rozwiązanie:</strong> NonceAccount przechowuje trwały hash; instrukcja <code>AdvanceNonce</code> generuje nowy bez konfliktu. Transakcja używa tego hash jako <code>recentBlockhash</code>.</p><p><strong>Flow:</strong> (1) Create NonceAccount (rent-exempt); (2) Przy budowie transakcji pobierz nonce; (3) Pierwsza instrukcja w transakcji: <code>AdvanceNonce</code> (zabezpiecza przed replay); (4) Podpis; (5) Wysłanie.</p><p><strong>Backend kolejka:</strong> Monitoruje wiek nonce (slot lag), odświeża jeśli zbyt stary. Blocker gdy konto w trakcie advance (race).</p><p><strong>Edge:</strong> Utrata NonceAccount (błąd). Brak advance instrukcji → replay ryzyko. Zbyt częste advance → marnowanie CU.</p><p><strong>Bezpieczeństwo:</strong> Oddziel autorytet nonce od fee payer. Audit log (nonce_before, nonce_after, slot).</p></div></div>

<div class="qa" id="p53"><div class="q">53) Compute Budget Program – limity i ceny?</div><div class="simple">Mówisz sieci: „daj mi więcej mocy” i „zapłacę X za priorytet”.</div><div class="deep"><p><strong>Elementy:</strong> <code>setComputeUnitLimit</code> (górny limit CU), <code>setComputeUnitPrice</code> (mikrolamports/CU). Wpływa na ordering przy przeciążeniu.</p><p><strong>Estymacja:</strong> Symuluj transakcję bez podwyższonych limitów → odczytaj <code>unitsConsumed</code> → dodaj bufor (np. +10%). Nie ustawaj wyżej niż potrzebne (koszt + możliwa odmowa).</p><p><strong>Pricing heurystyka:</strong> percentile z ostatnich X slotów (p75 CU price) lub dynamiczny wzrost przy rosnącym backlogu. Ustaw minimalny floor (ochrona przeciw spam low fee).</p><p><strong>Polityka backend:</strong> Whitelist typów transakcji które mogą zwiększyć limit (stake compounding, batch) vs zwykłe (balance check). Rate limit wysokich cen per użytkownik.</p><p><strong>Edge:</strong> Overprice + mały CU limit → przepłacasz bez korzyści. Zbyt wysoki limit CU może odrzucać transakcję (przekracza max globalny).</p></div></div>

<div class="qa" id="p54"><div class="q">54) Commitment levels i strategia potwierdzeń?</div><div class="simple">Sprawdzamy czy zapis jest „prawie pewny” czy „na 100%”.</div><div class="deep"><p><strong>Poziomy:</strong> processed (wstępnie wykonane), confirmed (większość walidatorów widzi), finalized (w root chain – bardzo małe ryzyko cofnięcia).</p><p><strong>UX strategia:</strong> Operacje low-risk (UI balance update) przy confirmed; high-risk (wypłaty, raport finansowy) przy finalized. Wyświetl wizualny pasek statusu.</p><p><strong>Backend:</strong> Poll <code>getSignatureStatuses</code> z <code>searchTransactionHistory=true</code> aby obsłużyć dłuższe finalizacje. Reorg detection: mismatch parentSlot, fallback re-query.</p><p><strong>Timeouty:</strong> Jeśli brak finalized > T sek, pokaż użytkownikowi opcje (czekaj / ponów) po drugiej symulacji.</p><p><strong>Edge:</strong> Blockhash expiry → resubmit z nowym blockhash (inny signature) + powiązanie oryginalnego operation_id.</p></div></div>

<div class="qa" id="p55"><div class="q">55) PDAs i seeds – bezpieczeństwo adresów programowych?</div><div class="simple">Specjalne adresy liczone z „ziarenek” – nie mają prywatnego klucza.</div><div class="deep"><p><strong>Mechanizm:</strong> <code>findProgramAddress</code> iteruje bump do znalezienia adresu poza krzywą Ed25519 (brak prywatnego klucza). Program autoryzuje działania używając <code>invoke_signed</code> z seeds + bump.</p><p><strong>Bezpieczeństwo:</strong> Waliduj w kodzie, że otrzymane PDA = spodziewane <code>Pubkey::find_program_address()</code>. Nie używaj danych użytkownika bez sanitacji jako seed (ryzyko kolizji/nadmiernych uprawnień).</p><p><strong>Versioning:</strong> Dodawaj prefix wersji do seeds ("v1", "v2") przy migracjach layoutu konta. Stare konta nadal czytane – fallback ścieżka.</p><p><strong>Kompresja danych:</strong> Twórz wiele małych PDA zamiast jednego masywnego (redukcja konfliktów). Zadbaj o deterministyczną kolejność seeds (unikaj różnic między klientami).</p><p><strong>Edge:</strong> Zmiana zestawu seeds = nowe adresy; migracja wymaga mapy (old→new). Limit długości seeds – unikaj excessive concatenation.</p></div></div>

<div class="qa" id="p56"><div class="q">56) CPI (Cross‑Program Invocation) i budowa programów?</div><div class="simple">Program A woła program B, np. tokenowy, żeby wykonać operację.</div><div class="deep"><p><strong>Cel:</strong> Reużycie logiki (np. SPL Token) bez duplikowania. Program przekazuje konta i dane do innego programu runtime.</p><p><strong>Wymagania:</strong> Wszystkie konta docelowego programu muszą być w message. Uprawnienia (writable, signer) muszą odpowiadać temu czego oczekuje program B.</p><p><strong>Bezpieczeństwo:</strong> Sprawdź owner kont (czy program B faktycznie jest właścicielem token account). Waliduj brak niespodziewanych zmian stanu po CPI (read after invoke).</p><p><strong>Limity CU:</strong> Każdy CPI konsumuje dodatkowe CU – unikaj kaskad CPI. Profiluj największe ścieżki; scal małe instrukcje.</p><p><strong>Wzorce:</strong> Facade program: agreguje kilka CPI w jedną wysokopoziomową instrukcję (UX). Guard rails: maks liczba CPI per transakcja.</p><p><strong>Edge:</strong> Program B upgrade może zmienić layout – integracja testów wykrywających breaking changes (idl diff).</p></div></div>

<div class="qa" id="p57"><div class="q">57) Błędy i logi programów – jak je dekodować?</div><div class="simple">Program wypisuje podpowiedzi – trzeba je dobrze przeczytać.</div><div class="deep"><p><strong>Źródła:</strong> <code>program log:</code> (debug/info), <code>custom program error: 0xXX</code> (kod zdefiniowany), <code>InstructionError</code> (systemowe, np. InvalidAccountData).</p><p><strong>Anchor:</strong> Mapuje kody na zdefiniowane enum + generuje <code>ErrorCode</code>. Możesz budować lokalizację błędów (stack marker) w debug builds.</p><p><strong>Frontend:</strong> Użyj <code>simulateTransaction</code> przed wysłaniem – parsuj <code>logs</code>, wykryj error pattern, pokaż user-friendly (np. „Brak uprawnień do konta stake”).</p><p><strong>Backend:</strong> Normalizuj błędy → HTTP status (InvalidInput 400, Conflict 409, Internal 500). Dodaj correlationId + slot w kontekście (Sentry breadcrumb).</p><p><strong>Narzędzia:</strong> Regex mapowanie, dictionary błędów, log level filtering. Lokalne testy integracyjne z symulacją aby zaktualizować katalog błędów.</p><p><strong>Edge:</strong> Niepełne logi przy limitach CU (program zakończy wcześniej). Fallback heurystyka: analiza InstructionError.</p></div></div>

<div class="qa" id="p58"><div class="q">58) Indeksowanie zdarzeń: logsSubscribe, Geyser plugin?</div><div class="simple">Słuchasz „krzyków” programów i zapisujesz je do bazy.</div><div class="deep"><p><strong>Źródła live:</strong> <code>logsSubscribe</code> (filtrowanie po programId), <code>blockSubscribe</code> (pełny blok), Geyser plugin (Kafka/GRPC) – wysoka przepustowość i mniej overhead RPC.</p><p><strong>Pipeline:</strong> Ingest → parsing prefixów (np. EVENT:Transfer) → normalizacja → walidacja signature → upsert do magazynu.</p><p><strong>Spójność:</strong> Reorg handling: jeśli block slot zastąpiony – rollback transakcji z tego slotu (maintain slot index). Idempotentny klucz: (signature, instruction_index).</p><p><strong>Backpressure:</strong> Gdy lag > X slotów – dynamic throttle subskrypcji, priorytety (stake events > inne). Retry z exponential jitter.</p><p><strong>Monitoring:</strong> Lag slots, parse error %, throughput, storage latency. Alerty na skok parse errors (możliwa zmiana formatu).</p></div></div>

<div class="qa" id="p59"><div class="q">59) WebSocket – backpressure i ponowne łączenie?</div><div class="simple">Jeśli stracisz połączenie, wracasz od miejsca, gdzie skończyłeś.</div><div class="deep"><p><strong>Mechanizmy niezawodności:</strong> Heartbeat ping/pong (brak odpowiedzi → reconnect). Silent disconnect detection (czas bez danych > threshold).</p><p><strong>Reconnect flow:</strong> Exponential backoff (base + jitter) aby uniknąć thundering herd. Po zestawieniu – REST catch‑up (signatures/blocks od ostatniego znanego slotu) → resume strumień WS.</p><p><strong>Backpressure:</strong> Lokalny bufor limit (N wiadomości) – gdy przepełniony odrzucaj najstarsze mniej krytyczne lub pauzuj subskrypcje drugorzędne. Dynamiczna redukcja zakresu subskrypcji (np. tylko summary zamiast pełnych logs).</p><p><strong>Bezpieczeństwo:</strong> Rate limit subskrypcji (uniemożliwia spam). Validacja server origin + TLS pinning (mitM).</p><p><strong>Observability:</strong> Metryki reconnect count, avg catch-up slots, backlog depth. Alert jeśli backlog stale rośnie.</p></div></div>

<div class="qa" id="p60"><div class="q">60) Limity rozmiaru transakcji i dzielenie operacji?</div><div class="simple">Jeśli nie mieści się w jednej, dzielisz na dwie.</div><div class="deep"><p><strong>Limity:</strong> Maks. długość message (bytes), liczba kont (w legacy), compute units, czas ważności blockhash. <strong>Ryzyko:</strong> Przekroczenie → <code>Transaction too large</code> albo abort w sig verify.</p><p><strong>Techniki redukcji:</strong> v0 + ALT (adresy przez indeksy), usuwanie zbędnych readonly kont, łączenie małych instrukcji jeśli nie zwiększa konfliktów.</p><p><strong>Dzielenie:</strong> Sekwencja wieloetapowa (init → create accounts → delegate). Jeśli atomiczność nie jest krytyczna, lepiej kilka mniejszych transakcji (większa szansa powodzenia). Zapis operation_id aby śledzić całość.</p><p><strong>Symulacja:</strong> Preflight: odczytaj CU usage + sprawdź wielkość. Jeśli blisko limitu → spróbuj ALT optimize.</p><p><strong>Edge:</strong> Race między dwiema częściami (część 2 zależy od stanu z części 1) – czekaj na confirmed/ finalized przed kontynuacją.</p></div></div>

<div class="qa" id="p61"><div class="q">61) State compression i Merkle‑proofs?</div><div class="simple">Upychasz dużo zapisów „w drzewo”, a na łańcuch dajesz tylko skrót.</div><div class="deep"><p><strong>Idea:</strong> Przechowujesz dużą ilość elementów (np. NFT) off-chain w strukturze Merkle; on-chain jedynie root + minimalne metadane. Aktualizacja leaf → rekalkulacja ścieżki.</p><p><strong>Dowód:</strong> Merkle proof (ciąg hashów siblings) pozwala zweryfikować w programie autentyczność elementu bez pełnej listy. Rozmiar proof ~ log2(N).</p><p><strong>Backend:</strong> Trzyma drzewo (levelized storage), generuje proof na żądanie (cache popularnych), waliduje spójność root vs on-chain. Snapshoty dla rewizji history.</p><p><strong>Frontend:</strong> Otrzymuje element + proof + root → wysyła w transakcji. Program weryfikuje hash chain.</p><p><strong>Edge:</strong> Nieaktualny root (drift) – transakcja odrzucona. Konflikt aktualizacji równoległych leafów → optymistyczne locki lub sekwencja.</p><p><strong>Bezpieczeństwo:</strong> Audyt integralności (periodic recompute), podpisane manifesty drzewa. Ochrona przed partial update (sprawdź depth).</p></div></div>

<div class="qa" id="p62"><div class="q">62) SPL Token‑2022 – rozszerzenia?</div><div class="simple">Tokeny z dodatkowymi funkcjami (np. opłaty, prywatność).</div><div class="deep"><p><strong>Rozszerzenia:</strong> Transfer fee (część transferu trafia do określonego konta), interest-bearing (akumulacja odsetek), confidential transfers (ukrycie wartości poprzez kryptografię – np. elGamal).</p><p><strong>Layout:</strong> Mint/Account zawiera pola rozszerzeń – parser musi sprawdzić maskę i zdekodować dynamiczne sekcje. Użyj oficjalnych bibliotek do uniknięcia błędów offsetów.</p><p><strong>UX:</strong> Wyświetl breakdown (kwota brutto, fee, net). Dla confidential – wskaż że portfele mogą nie pokazać wartości bez odszyfrowania (view key).</p><p><strong>CPI bezpieczeństwo:</strong> Waliduj authority i parametry fee; unikaj nieświadomego naliczania opłat przy integracji z innymi programami (fuzz test różne rozszerzenia).</p><p><strong>Observability:</strong> Metryki: średni fee %, interest accrual per epoch. Alert jeśli fee nagle rośnie (potencjalna zmiana polityki).</p><p><strong>Migracje:</strong> Dodanie nowej ekstencji → aktualizacja parsera + version flag; fallback dla starczych klientów (pokaz ostrzeżenie).</p></div></div>

<div class="footer">© 2025 – 50+ pytań przygotowawczych Full Stack (Solana). Drukuj tę stronę aby uzyskać PDF.</div><script class="print-hide">(function(){const printBtn=document.getElementById('print');if(!printBtn) return;const b=document.createElement('button');b.id='downloadPdf';b.textContent='Pobierz PDF';b.style.cssText=printBtn.style.cssText;b.onclick=function(){window.print();};printBtn.parentNode.insertBefore(b, printBtn.nextSibling);})();</script></main></body></html>